// This file was auto-generated by Fern from our API Definition.

package client

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

const (
	defaultBaseURL = "https://cloud.langfuse.com"
	defaultTimeout = 30 * time.Second
)

// Client represents the Langfuse API client
type Client struct {
	baseURL    string
	publicKey  string
	secretKey  string
	httpClient *http.Client
}

// Option is a functional option for configuring the Client
type Option func(*Client)

// WithBaseURL sets a custom base URL for the client
func WithBaseURL(baseURL string) Option {
	return func(c *Client) {
		c.baseURL = baseURL
	}
}

// WithHTTPClient sets a custom HTTP client
func WithHTTPClient(httpClient *http.Client) Option {
	return func(c *Client) {
		c.httpClient = httpClient
	}
}

// WithTimeout sets a custom timeout for the HTTP client
func WithTimeout(timeout time.Duration) Option {
	return func(c *Client) {
		c.httpClient.Timeout = timeout
	}
}

// NewClient creates a new Langfuse client
func NewClient(publicKey, secretKey string, opts ...Option) *Client {
	client := &Client{
		baseURL:   defaultBaseURL,
		publicKey: publicKey,
		secretKey: secretKey,
		httpClient: &http.Client{
			Timeout: defaultTimeout,
		},
	}

	for _, opt := range opts {
		opt(client)
	}

	return client
}

// doRequest performs an HTTP request with authentication
func (c *Client) doRequest(ctx context.Context, method, path string, body interface{}, result interface{}) error {
	var reqBody io.Reader
	if body != nil {
		jsonData, err := json.Marshal(body)
		if err != nil {
			return fmt.Errorf("failed to marshal request body: %w", err)
		}
		reqBody = bytes.NewBuffer(jsonData)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, reqBody)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	// Add Basic Auth
	auth := base64.StdEncoding.EncodeToString([]byte(c.publicKey + ":" + c.secretKey))
	req.Header.Set("Authorization", "Basic "+auth)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to perform request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(bodyBytes))
	}

	if result != nil && resp.StatusCode != http.StatusNoContent {
		if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
			return fmt.Errorf("failed to decode response: %w", err)
		}
	}

	return nil
}

// Health checks the health of the API
func (c *Client) Health(ctx context.Context) (*HealthResponse, error) {
	var response HealthResponse
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/health", nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetProjects retrieves all projects
func (c *Client) GetProjects(ctx context.Context) (*Projects, error) {
	var response Projects
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/projects", nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ===== Trace Methods =====

// CreateTrace creates a new trace
func (c *Client) CreateTrace(ctx context.Context, req *CreateTraceBody) error {
	return c.doRequest(ctx, http.MethodPost, "/api/public/traces", req, nil)
}

// GetTrace retrieves a trace by ID
func (c *Client) GetTrace(ctx context.Context, traceID string) (*Trace, error) {
	var response Trace
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/traces/"+url.PathEscape(traceID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// UpdateTrace updates a trace
func (c *Client) UpdateTrace(ctx context.Context, traceID string, req *UpdateTraceBody) error {
	return c.doRequest(ctx, http.MethodPatch, "/api/public/traces/"+url.PathEscape(traceID), req, nil)
}

// ===== Observation Methods =====

// CreateEvent creates a new event observation
func (c *Client) CreateEvent(ctx context.Context, req *CreateEventBody) error {
	return c.doRequest(ctx, http.MethodPost, "/api/public/events", req, nil)
}

// UpdateEvent updates an event observation
func (c *Client) UpdateEvent(ctx context.Context, eventID string, req *UpdateEventBody) error {
	return c.doRequest(ctx, http.MethodPatch, "/api/public/events/"+url.PathEscape(eventID), req, nil)
}

// CreateSpan creates a new span observation
func (c *Client) CreateSpan(ctx context.Context, req *CreateSpanBody) error {
	return c.doRequest(ctx, http.MethodPost, "/api/public/spans", req, nil)
}

// UpdateSpan updates a span observation
func (c *Client) UpdateSpan(ctx context.Context, spanID string, req *UpdateSpanBody) error {
	return c.doRequest(ctx, http.MethodPatch, "/api/public/spans/"+url.PathEscape(spanID), req, nil)
}

// CreateGeneration creates a new generation observation
func (c *Client) CreateGeneration(ctx context.Context, req *CreateGenerationBody) error {
	return c.doRequest(ctx, http.MethodPost, "/api/public/generations", req, nil)
}

// UpdateGeneration updates a generation observation
func (c *Client) UpdateGeneration(ctx context.Context, generationID string, req *UpdateGenerationBody) error {
	return c.doRequest(ctx, http.MethodPatch, "/api/public/generations/"+url.PathEscape(generationID), req, nil)
}

// GetObservation retrieves an observation by ID
func (c *Client) GetObservation(ctx context.Context, observationID string) (*Observation, error) {
	var response Observation
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/observations/"+url.PathEscape(observationID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetObservations retrieves observations with optional filtering
func (c *Client) GetObservations(ctx context.Context, params *GetObservationsParams) (*ObservationsView, error) {
	path := "/api/public/observations"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if params.Name != nil {
			query.Set("name", *params.Name)
		}
		if params.UserID != nil {
			query.Set("userId", *params.UserID)
		}
		if params.Type != nil {
			query.Set("type", string(*params.Type))
		}
		if params.TraceID != nil {
			query.Set("traceId", *params.TraceID)
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response ObservationsView
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetObservationsParams represents query parameters for GetObservations
type GetObservationsParams struct {
	Page   *int
	Limit  *int
	Name   *string
	UserID *string
	Type   *ObservationType
	TraceID *string
}

// ===== Score Methods =====

// CreateScore creates a new score
func (c *Client) CreateScore(ctx context.Context, req *CreateScoreRequest) (*CreateScoreResponse, error) {
	var response CreateScoreResponse
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/scores", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetScore retrieves a score by ID
func (c *Client) GetScore(ctx context.Context, scoreID string) (*Score, error) {
	var response Score
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/scores/"+url.PathEscape(scoreID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetScores retrieves scores with optional filtering
func (c *Client) GetScores(ctx context.Context, params *GetScoresParams) (*GetScoresResponse, error) {
	path := "/api/public/scores"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if params.TraceID != nil {
			query.Set("traceId", *params.TraceID)
		}
		if params.UserID != nil {
			query.Set("userId", *params.UserID)
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response GetScoresResponse
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetScoresParams represents query parameters for GetScores
type GetScoresParams struct {
	Page    *int
	Limit   *int
	TraceID *string
	UserID  *string
}

// DeleteScore deletes a score by ID
func (c *Client) DeleteScore(ctx context.Context, scoreID string) error {
	return c.doRequest(ctx, http.MethodDelete, "/api/public/scores/"+url.PathEscape(scoreID), nil, nil)
}

// ===== Dataset Methods =====

// CreateDataset creates a new dataset
func (c *Client) CreateDataset(ctx context.Context, req *CreateDatasetRequest) (*Dataset, error) {
	var response Dataset
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/datasets", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetDataset retrieves a dataset by name
func (c *Client) GetDataset(ctx context.Context, datasetName string) (*Dataset, error) {
	var response Dataset
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/datasets/"+url.PathEscape(datasetName), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetDatasets retrieves all datasets with pagination
func (c *Client) GetDatasets(ctx context.Context, params *PaginationParams) (*PaginatedDatasets, error) {
	path := "/api/public/datasets"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedDatasets
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// PaginationParams represents common pagination parameters
type PaginationParams struct {
	Page  *int
	Limit *int
}

// CreateDatasetItem creates a new dataset item
func (c *Client) CreateDatasetItem(ctx context.Context, req *CreateDatasetItemRequest) (*DatasetItem, error) {
	var response DatasetItem
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/dataset-items", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetDatasetItem retrieves a dataset item by ID
func (c *Client) GetDatasetItem(ctx context.Context, itemID string) (*DatasetItem, error) {
	var response DatasetItem
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/dataset-items/"+url.PathEscape(itemID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetDatasetItems retrieves items for a dataset
func (c *Client) GetDatasetItems(ctx context.Context, datasetName string, params *PaginationParams) (*PaginatedDatasetItems, error) {
	path := "/api/public/datasets/" + url.PathEscape(datasetName) + "/items"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedDatasetItems
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// CreateDatasetRun creates a new dataset run
func (c *Client) CreateDatasetRun(ctx context.Context, req *CreateDatasetRunRequest) (*DatasetRun, error) {
	var response DatasetRun
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/dataset-runs", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetDatasetRun retrieves a dataset run by ID
func (c *Client) GetDatasetRun(ctx context.Context, runID string) (*DatasetRun, error) {
	var response DatasetRun
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/dataset-runs/"+url.PathEscape(runID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetDatasetRuns retrieves runs for a dataset
func (c *Client) GetDatasetRuns(ctx context.Context, datasetName string, params *PaginationParams) (*PaginatedDatasetRuns, error) {
	path := "/api/public/datasets/" + url.PathEscape(datasetName) + "/runs"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedDatasetRuns
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// CreateDatasetRunItem creates a new dataset run item
func (c *Client) CreateDatasetRunItem(ctx context.Context, req *CreateDatasetRunItemRequest) (*DatasetRunItem, error) {
	var response DatasetRunItem
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/dataset-run-items", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ===== Session Methods =====

// GetSession retrieves a session by ID
func (c *Client) GetSession(ctx context.Context, sessionID string) (*SessionWithTraces, error) {
	var response SessionWithTraces
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/sessions/"+url.PathEscape(sessionID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetSessions retrieves all sessions with pagination
func (c *Client) GetSessions(ctx context.Context, params *PaginationParams) (*PaginatedSessions, error) {
	path := "/api/public/sessions"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedSessions
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ===== Model Methods =====

// CreateModel creates a new model configuration
func (c *Client) CreateModel(ctx context.Context, req *CreateModelRequest) (*Model, error) {
	var response Model
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/models", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetModel retrieves a model by ID
func (c *Client) GetModel(ctx context.Context, modelID string) (*Model, error) {
	var response Model
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/models/"+url.PathEscape(modelID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetModels retrieves all models with pagination
func (c *Client) GetModels(ctx context.Context, params *PaginationParams) (*PaginatedModels, error) {
	path := "/api/public/models"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedModels
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// DeleteModel deletes a model by ID
func (c *Client) DeleteModel(ctx context.Context, modelID string) error {
	return c.doRequest(ctx, http.MethodDelete, "/api/public/models/"+url.PathEscape(modelID), nil, nil)
}

// ===== Prompt Methods =====

// GetPrompt retrieves a prompt by name and version
func (c *Client) GetPrompt(ctx context.Context, promptName string, version *int, label *string) (interface{}, error) {
	path := "/api/public/prompts/" + url.PathEscape(promptName)
	query := url.Values{}
	if version != nil {
		query.Set("version", strconv.Itoa(*version))
	}
	if label != nil {
		query.Set("label", *label)
	}
	if len(query) > 0 {
		path += "?" + query.Encode()
	}

	var response interface{}
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return response, nil
}

// GetPrompts retrieves all prompts with pagination
func (c *Client) GetPrompts(ctx context.Context, params *GetPromptsParams) (*PromptMetaListResponse, error) {
	path := "/api/public/prompts"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if params.Name != nil {
			query.Set("name", *params.Name)
		}
		if params.Label != nil {
			query.Set("label", *params.Label)
		}
		if params.Tag != nil {
			query.Set("tag", *params.Tag)
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PromptMetaListResponse
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetPromptsParams represents query parameters for GetPrompts
type GetPromptsParams struct {
	Page  *int
	Limit *int
	Name  *string
	Label *string
	Tag   *string
}

// CreateChatPrompt creates a new chat prompt
func (c *Client) CreateChatPrompt(ctx context.Context, req *CreateChatPromptRequest) (*ChatPrompt, error) {
	var response ChatPrompt
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/prompts", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// CreateTextPrompt creates a new text prompt
func (c *Client) CreateTextPrompt(ctx context.Context, req *CreateTextPromptRequest) (*TextPrompt, error) {
	var response TextPrompt
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/prompts", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ===== Comment Methods =====

// CreateComment creates a new comment
func (c *Client) CreateComment(ctx context.Context, req *CreateCommentRequest) (*CreateCommentResponse, error) {
	var response CreateCommentResponse
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/comments", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetComment retrieves a comment by ID
func (c *Client) GetComment(ctx context.Context, commentID string) (*Comment, error) {
	var response Comment
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/comments/"+url.PathEscape(commentID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetComments retrieves comments with optional filtering
func (c *Client) GetComments(ctx context.Context, params *GetCommentsParams) (*GetCommentsResponse, error) {
	path := "/api/public/comments"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if params.ObjectType != nil {
			query.Set("objectType", string(*params.ObjectType))
		}
		if params.ObjectID != nil {
			query.Set("objectId", *params.ObjectID)
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response GetCommentsResponse
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetCommentsParams represents query parameters for GetComments
type GetCommentsParams struct {
	Page       *int
	Limit      *int
	ObjectType *CommentObjectType
	ObjectID   *string
}

// ===== Media Methods =====

// GetMedia retrieves media metadata by ID
func (c *Client) GetMedia(ctx context.Context, mediaID string) (*GetMediaResponse, error) {
	var response GetMediaResponse
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/media/"+url.PathEscape(mediaID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetMediaUploadURL retrieves an upload URL for media
func (c *Client) GetMediaUploadURL(ctx context.Context, req *GetMediaUploadUrlRequest) (*GetMediaUploadUrlResponse, error) {
	var response GetMediaUploadUrlResponse
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/media", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// PatchMedia updates media metadata
func (c *Client) PatchMedia(ctx context.Context, mediaID string, req *PatchMediaBody) error {
	return c.doRequest(ctx, http.MethodPatch, "/api/public/media/"+url.PathEscape(mediaID), req, nil)
}

// ===== Metrics Methods =====

// GetDailyMetrics retrieves daily metrics
func (c *Client) GetDailyMetrics(ctx context.Context, params *GetDailyMetricsParams) ([]DailyMetrics, error) {
	path := "/api/public/metrics/daily"
	if params != nil {
		query := url.Values{}
		if params.TraceName != nil {
			query.Set("traceName", *params.TraceName)
		}
		if params.UserID != nil {
			query.Set("userId", *params.UserID)
		}
		if params.Tags != nil {
			for _, tag := range params.Tags {
				query.Add("tags", tag)
			}
		}
		if params.FromTimestamp != nil {
			query.Set("fromTimestamp", params.FromTimestamp.Format(time.RFC3339))
		}
		if params.ToTimestamp != nil {
			query.Set("toTimestamp", params.ToTimestamp.Format(time.RFC3339))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response []DailyMetrics
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return response, nil
}

// GetDailyMetricsParams represents query parameters for GetDailyMetrics
type GetDailyMetricsParams struct {
	TraceName     *string
	UserID        *string
	Tags          []string
	FromTimestamp *time.Time
	ToTimestamp   *time.Time
}

// ===== Ingestion Methods =====

// Ingest sends a batch of events to the ingestion API
func (c *Client) Ingest(ctx context.Context, req *IngestionRequest) (*IngestionResponse, error) {
	var response IngestionResponse
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/ingestion", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ===== Annotation Queue Methods =====

// ListAnnotationQueues retrieves all annotation queues
func (c *Client) ListAnnotationQueues(ctx context.Context, params *PaginationParams) (*PaginatedAnnotationQueues, error) {
	path := "/api/public/annotation-queues"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedAnnotationQueues
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// CreateAnnotationQueue creates a new annotation queue
func (c *Client) CreateAnnotationQueue(ctx context.Context, req *CreateAnnotationQueueRequest) (*AnnotationQueue, error) {
	var response AnnotationQueue
	if err := c.doRequest(ctx, http.MethodPost, "/api/public/annotation-queues", req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetAnnotationQueue retrieves an annotation queue by ID
func (c *Client) GetAnnotationQueue(ctx context.Context, queueID string) (*AnnotationQueue, error) {
	var response AnnotationQueue
	if err := c.doRequest(ctx, http.MethodGet, "/api/public/annotation-queues/"+url.PathEscape(queueID), nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ListAnnotationQueueItems retrieves items for an annotation queue
func (c *Client) ListAnnotationQueueItems(ctx context.Context, queueID string, params *ListAnnotationQueueItemsParams) (*PaginatedAnnotationQueueItems, error) {
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/items"
	if params != nil {
		query := url.Values{}
		if params.Page != nil {
			query.Set("page", strconv.Itoa(*params.Page))
		}
		if params.Limit != nil {
			query.Set("limit", strconv.Itoa(*params.Limit))
		}
		if params.Status != nil {
			query.Set("status", string(*params.Status))
		}
		if len(query) > 0 {
			path += "?" + query.Encode()
		}
	}

	var response PaginatedAnnotationQueueItems
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// ListAnnotationQueueItemsParams represents query parameters for ListAnnotationQueueItems
type ListAnnotationQueueItemsParams struct {
	Page   *int
	Limit  *int
	Status *AnnotationQueueStatus
}

// CreateAnnotationQueueItem creates a new annotation queue item
func (c *Client) CreateAnnotationQueueItem(ctx context.Context, queueID string, req *CreateAnnotationQueueItemRequest) (*AnnotationQueueItem, error) {
	var response AnnotationQueueItem
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/items"
	if err := c.doRequest(ctx, http.MethodPost, path, req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// GetAnnotationQueueItem retrieves an annotation queue item
func (c *Client) GetAnnotationQueueItem(ctx context.Context, queueID, itemID string) (*AnnotationQueueItem, error) {
	var response AnnotationQueueItem
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/items/" + url.PathEscape(itemID)
	if err := c.doRequest(ctx, http.MethodGet, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// UpdateAnnotationQueueItem updates an annotation queue item
func (c *Client) UpdateAnnotationQueueItem(ctx context.Context, queueID, itemID string, req *UpdateAnnotationQueueItemRequest) (*AnnotationQueueItem, error) {
	var response AnnotationQueueItem
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/items/" + url.PathEscape(itemID)
	if err := c.doRequest(ctx, http.MethodPatch, path, req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// DeleteAnnotationQueueItem deletes an annotation queue item
func (c *Client) DeleteAnnotationQueueItem(ctx context.Context, queueID, itemID string) (*DeleteAnnotationQueueItemResponse, error) {
	var response DeleteAnnotationQueueItemResponse
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/items/" + url.PathEscape(itemID)
	if err := c.doRequest(ctx, http.MethodDelete, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// CreateAnnotationQueueAssignment creates an assignment for a user to an annotation queue
func (c *Client) CreateAnnotationQueueAssignment(ctx context.Context, queueID string, req *AnnotationQueueAssignmentRequest) (*CreateAnnotationQueueAssignmentResponse, error) {
	var response CreateAnnotationQueueAssignmentResponse
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/assignments"
	if err := c.doRequest(ctx, http.MethodPost, path, req, &response); err != nil {
		return nil, err
	}
	return &response, nil
}

// DeleteAnnotationQueueAssignment deletes an assignment from an annotation queue
func (c *Client) DeleteAnnotationQueueAssignment(ctx context.Context, queueID, userID string) (*DeleteAnnotationQueueAssignmentResponse, error) {
	var response DeleteAnnotationQueueAssignmentResponse
	path := "/api/public/annotation-queues/" + url.PathEscape(queueID) + "/assignments/" + url.PathEscape(userID)
	if err := c.doRequest(ctx, http.MethodDelete, path, nil, &response); err != nil {
		return nil, err
	}
	return &response, nil
}
